//#include "DedxPar.hh"
#include "Helix.hh"
#include "G4TransportationManager.hh"
#include "G4FieldManager.hh"
#include "G4MagneticField.hh"
#include "CLHEP/Geometry/Vector3D.h"
#include "CLHEP/Geometry/Point3D.h"
#include "TVector3.h"

#ifndef ENABLE_BACKWARDS_COMPATIBILITY
typedef HepGeom::Point3D<double> HepPoint3D;
#endif

#ifndef ENABLE_BACKWARDS_COMPATIBILITY
typedef HepGeom::Vector3D<double> HepVector3D;
#endif


#include "BesMdcSD.hh"
#include "G4HCofThisEvent.hh"
#include "G4Step.hh"
#include "G4ThreeVector.hh"
#include "G4SDManager.hh"
#include "G4UnitsTable.hh"
#include "G4ios.hh"
#include "G4RunManager.hh"
#include "ReadBoostRoot.hh"
#include "G4Svc/IG4Svc.h"
#include "G4Svc/G4Svc.h"
#include "CalibDataSvc/ICalibRootSvc.h"
#include "CalibData/Dedx/DedxCalibData.h"
#include "CalibData/Dedx/DedxSimData.h"
#include "GaudiKernel/DataSvc.h"
#include "TFile.h"
#include "TH1F.h"
#include "TH2D.h"

#include "GaudiKernel/Bootstrap.h"
#include "GaudiKernel/IService.h"
#include "GaudiKernel/Service.h"
#include "GaudiKernel/SmartDataPtr.h"

#include <iostream>

int SDlastLayer,SDlastCell,SDenter;
BesMdcSD::BesMdcSD(G4String name)
:BesSensitiveDetector(name)
{
    collectionName.insert("BesMdcHitsCollection");
    collectionName.insert("BesMdcTruthCollection");
  
    mdcGeoPointer=BesMdcGeoParameter::GetGeo();
    mdcCalPointer=new BesMdcCalTransfer;
  
    IMdcGeomSvc* ISvc;
    StatusCode sc=Gaudi::svcLocator()->service("MdcGeomSvc", ISvc);
    if (!sc.isSuccess()) 
      std::cout<<"BesMdcSD::Could not open MdcGeomSvc"<<std::endl;
    mdcGeomSvc=dynamic_cast<MdcGeomSvc *>(ISvc);
  
    IG4Svc* tmpSvc;
    sc=Gaudi::svcLocator()->service("G4Svc", tmpSvc);
    if (!sc.isSuccess())
      G4cout <<" MdcSD::Error,could not open G4Svc"<<G4endl;
    m_G4Svc=dynamic_cast<G4Svc *>(tmpSvc); 
  
    if(m_G4Svc->GetMdcDedxFlag()==1){
      G4cout <<" MdcSD: Use sampled dedx instead of Geant4 value"<<G4endl;
      dedxFuncInti();
    }

    ////dedx sim
    
    //get DedxSimData
    std::string dedxTDSPath = "/Calib/DedxSim";
    IDataProviderSvc* pCalibDataSvc;
    sc = Gaudi::svcLocator()->service("CalibDataSvc", pCalibDataSvc, true);
    if (!sc.isSuccess())
        std::cout << "BesMdcSD::Could not open CalibDataSvc" << std::endl;
    m_calibDataSvc = dynamic_cast<CalibDataSvc*>(pCalibDataSvc);
    if (!sc.isSuccess())
    {
        std::cout << "Could not get CalibDataSvc"
                  << std::endl;
    }
    SmartDataPtr<CalibData::DedxSimData> pDedxSimData(m_calibDataSvc, dedxTDSPath);
    m_numDedxHists = pDedxSimData->gethistNo();
    m_numBg = pDedxSimData->getRangeNo();
    m_dedx_hists = new TH1F[m_numDedxHists];
    for (G4int i = 0; i < m_numBg; i++)
    {
        m_bgRange.push_back(pDedxSimData->getRange(i));
    }
    for (G4int i = 0; i < m_numDedxHists; i++)
    {
        m_dedx_hists[i] = pDedxSimData->getHist(i);
    }

    //get CalibCurSvc
    IDedxCurSvc* tmp_dedxCurSvc;
    sc = Gaudi::svcLocator()->service("DedxCurSvc", tmp_dedxCurSvc, true);
    if (!sc.isSuccess())
    {
        std::cout << "Could not get DedxCurSvc"
                  << std::endl;
    }
    m_pDedxCurSvc = dynamic_cast<DedxCurSvc*>(tmp_dedxCurSvc);

    if(m_G4Svc->MdcRootFlag())
    {
      m_tupleMdc = m_G4Svc->GetTupleMdc();
      sc = m_tupleMdc->addItem("betaGamma",m_betaGamma);
      sc = m_tupleMdc->addItem("fitval",m_fitval);
      sc = m_tupleMdc->addItem("dedx",m_dedx);
      sc = m_tupleMdc->addItem("de",m_de);
      //sc = m_tupleMdc->addItem("length",m_length);
      //sc = m_tupleMdc->addItem("random",m_random);
      sc = m_tupleMdc->addItem("charge", m_charge);
      sc = m_tupleMdc->addItem("costheta", m_costheta);
    }
}

BesMdcSD::~BesMdcSD(){
  delete []m_dedx_hists;
}

void BesMdcSD::Initialize(G4HCofThisEvent* HCE)
{
  hitsCollection = new BesMdcHitsCollection
                          (SensitiveDetectorName,collectionName[0]); 
  static G4int HCID = -1;
  if(HCID<0)
  { HCID = G4SDManager::GetSDMpointer()->GetCollectionID(collectionName[0]); }
  HCE->AddHitsCollection( HCID, hitsCollection ); 
  G4int i,j;
  for(i=0; i<43;i++){
    for(j=0;j<288;j++){
      hitPointer[i][j]=-1;
      truthPointer[i][j]=-1;
    }
  }
}

//for MC Truth
void BesMdcSD::BeginOfTruthEvent(const G4Event* evt)
{  
SDlastLayer=-1;
SDlastCell=-1;
SDenter=0;  
  truthCollection = new BesMdcHitsCollection
                          (SensitiveDetectorName,collectionName[1]); 
  //  G4cout<<" begin event "<<evt->GetEventID()<<G4endl;
}

void BesMdcSD::EndOfTruthEvent(const G4Event* evt)
{  static G4int HLID=-1;
  if(HLID<0)
  {
    HLID = G4SDManager::GetSDMpointer()->
		GetCollectionID(collectionName[1]); 
  }
  G4HCofThisEvent* HCE = evt->GetHCofThisEvent();
  HCE->AddHitsCollection(HLID,truthCollection);
}

G4bool BesMdcSD::ProcessHits(G4Step* aStep,G4TouchableHistory*)
{
if(SDenter==1)return false;
  G4Track* gTrack = aStep->GetTrack() ;

  G4double globalT=gTrack->GetGlobalTime();//Time since the event in which the track belongs is created
  if(isnan(globalT)){
    G4cout<<"MdcSD:error, globalT is nan "<<G4endl;
    return false;
  }
  if(globalT > 2000)return false; //MDC T window is 2 microsecond 

  //skip neutral tracks
  G4int charge = gTrack->GetDefinition()->GetPDGCharge();
  if (charge == 0) return false;

  //skip no energy deposit tracks
  G4double stepLength=aStep->GetStepLength();
  if(stepLength==0){
    //    G4cout<<"step length equal 0!!"<<G4endl;
    return false;
  }

  G4double edep = aStep->GetTotalEnergyDeposit() / stepLength;
  if(edep==0.) return false;

  // get position of the track at the beginning and at the end of step
  G4StepPoint* prePoint  = aStep->GetPreStepPoint() ;
  G4StepPoint* postPoint = aStep->GetPostStepPoint() ;

  //get position coordinate
  G4ThreeVector pointIn  = prePoint->GetPosition();
  G4ThreeVector pointOut = postPoint->GetPosition();

  // get physical volumes
  const G4VTouchable *touchable = prePoint->GetTouchable();
  G4VPhysicalVolume *volume = touchable->GetVolume(0);

  G4double driftD = 0;
  G4double driftT = 0;
  G4double edepTemp = 0;
  G4double lengthTemp = 0;
  G4int cellId=0;
  G4int layerId = touchable->GetVolume(1)->GetCopyNo();
  if(volume->IsReplicated()){
    cellId  = touchable->GetReplicaNumber();
  }else{
    cellId=touchable->GetVolume(0)->GetCopyNo();
  }
//  if(layerId==18&&(cellId==27||cellId==42))return false; // no sense wire 

  if(ReadBoostRoot::GetMdc() == 2) { //gdml
    //layerId  0-35 -> CopyNo 0-35 in gdml 
    //layerId 36-42 -> CopyNo (36,37),(38,39),...(48,49)    
    if(layerId >= 36) layerId = 36 + (layerId-36)/2;
  }

  G4double halfLayerLength=mdcGeomSvc->Layer(layerId)->Length()/2.;
  if(((fabs(pointIn.z())-halfLayerLength)>-7.)
     &&((fabs(pointOut.z())-halfLayerLength)>-7.))return false;//Out sensitive area

  G4int trackID= gTrack->GetTrackID(); //G4 track ID of current track.
  G4int truthID, g4TrackID;
  GetCurrentTrackIndex(truthID, g4TrackID); //ID of current primary track.
  
  G4double theta=gTrack->GetMomentumDirection().theta();

  G4ThreeVector hitPosition=0;
  G4double transferT=0;
//G4cout<<"track "<<trackID<<" truth "<<truthID<<" g4track "<<g4TrackID<<"layer "<<layerId<<" cell "<<cellId<<G4endl;
//G4cout<<" pointIn "<<pointIn<<" pointOut "<<pointOut<<G4endl;
  driftD  = Distance(layerId,cellId,pointIn,pointOut,hitPosition,transferT);
//G4cout<<"hitPosition "<<hitPosition<<" driftD "<<driftD<<G4endl;

G4double tempDriftD=driftD;
G4int wrongFlag=0;

  const G4ThreeVector momIn(prePoint->GetMomentum().x(), prePoint->GetMomentum().y(),

                               prePoint->GetMomentum().z());
/*
  G4cout<<G4endl;
G4cout<<"layer "<<layerId<<" cell "<<cellId<<G4endl;
  G4cout<<"line fit driftD "<<driftD<<" pointIn "<<pointIn<<" pointOut "<<pointOut<<" hitPosition "<<hitPosition<<" mom "<<momIn<<G4endl;
if((hitPosition.x()-pointIn.x())*(hitPosition.x()-pointOut.x())>0)G4cout<<"Wrong position !!!!!!!!!!!!!!!!!!!"<<G4endl;
if((hitPosition.y()-pointIn.y())*(hitPosition.y()-pointOut.y())>0)G4cout<<"Wrong position !!!!!!!!!!!!!!!!!!!"<<G4endl;
if((hitPosition.z()-pointIn.z())*(hitPosition.z()-pointOut.z())>0)G4cout<<"Wrong position !!!!!!!!!!!!!!!!!!!"<<G4endl;
*/
  //m_betaGamma=driftD;


G4double pos[3]; pos[0] = pointIn.x(); pos[1] = pointIn.y(); pos[2] = pointIn.z();

          G4double Bfield[3];

           const G4Field* field = G4TransportationManager::GetTransportationManager()->GetFieldManager()->GetDetectorField();
           field->GetFieldValue(pos, Bfield);



          m_nonUniformField = 1;

           if (Bfield[0] == 0. &&

              Bfield[1] == 0. &&

              Bfield[2] != 0.) m_nonUniformField = 0;


          G4double B_kG[3] = {Bfield[0] / kilogauss,
                                Bfield[1] / kilogauss,
                                Bfield[2] / kilogauss
                               };
        //  G4cout<<" field x"<<Bfield[0]<<" y "<<Bfield[1]<<" z "<<Bfield[2]<<" uniform "<<m_nonUniformField<<" B_KG x "<<B_kG[0]<<" y "<<B_kG[1]<<" z "<<B_kG[2]<<G4endl;


           HepPoint3D x(pos[0], pos[1], pos[2]); x *= (1. / cm);

           HepVector3D p(prePoint->GetMomentum().x(),

                        prePoint->GetMomentum().y(),

                        prePoint->GetMomentum().z()); p *= (1. / GeV);
          // G4cout<<"x:cm "<<x<<" p GeV "<<p<<G4endl; 

          Helix tmp(x, p, charge);

          tmp.bFieldZ(B_kG[2]);

          tmp.ignoreErrorMatrix();
          G4ThreeVector east=mdcGeomSvc->Wire(layerId,cellId)->Backward();
          G4ThreeVector west=mdcGeomSvc->Wire(layerId,cellId)->Forward();

          //G4cout<<" east "<<east<<" west "<<west<<G4endl;

           HepPoint3D fwd(west.x(), west.y(),
                          west.z());
           fwd *= (1./cm);
           HepPoint3D bck(east.x(),
                          east.y(),
                          east.z());
           bck *= (1./cm);

           HepVector3D wire = fwd - bck;
            HepPoint3D tryp =

             (x.z() - bck.z()) / wire.z() * wire + bck;

           tmp.pivot(tryp);

           tryp = (tmp.x(0.).z() - bck.z()) / wire.z() * wire + bck;

           tmp.pivot(tryp);

           tryp = (tmp.x(0.).z() - bck.z()) / wire.z() * wire + bck;

           tmp.pivot(tryp);


           driftD = std::abs(tmp.a()[0]) * cm;

           hitPosition.setX(tmp.x(0.).x()*cm);

           hitPosition.setY(tmp.x(0.).y()*cm);

         hitPosition.setZ(tmp.x(0.).z()*cm);
 /*
         G4cout<<" pre fit drfitD "<<driftD<<" hitposition "<<hitPosition<<G4endl;
if((hitPosition.x()-pointIn.x())*(hitPosition.x()-pointOut.x())>0)G4cout<<"Wrong position !!!!!!!!!!!!!!!!!!!"<<G4endl;
if((hitPosition.y()-pointIn.y())*(hitPosition.y()-pointOut.y())>0)G4cout<<"Wrong position !!!!!!!!!!!!!!!!!!!"<<G4endl;
if((hitPosition.z()-pointIn.z())*(hitPosition.z()-pointOut.z())>0)G4cout<<"Wrong position !!!!!!!!!!!!!!!!!!!"<<G4endl;
*/
         //m_fitval=driftD;

           for_Rotat(B_kG);

           G4double xwb4(bck.x()), ywb4(bck.y()), zwb4(bck.z());

           G4double xwf4(fwd.x()), ywf4(fwd.y()), zwf4(fwd.z());

           G4double xp(x.x()), yp(x.y()), zp(x.z());

           G4double px(p.x()), py(p.y()), pz(p.z());

           G4double q2[3] = {0.}, q1[3] = {0.};

           const G4int ntryMax(100);

           G4double dist = driftD / cm;

           G4int ntry(999);

           HELWIR(xwb4, ywb4, zwb4, xwf4, ywf4, zwf4,

                  xp,   yp,   zp,   px,   py,   pz,

                  B_kG, charge, ntryMax, dist, q2, q1, ntry);
           if (ntry <= ntryMax) {

             driftD = dist * cm;

              hitPosition.setX(q1[0]);

              hitPosition.setY(q1[1]);

              hitPosition.setZ(q1[2]);

              hitPosition *= cm;


           }
/*
           G4cout<<"helix fit drftD "<<driftD<<" hitposition "<<hitPosition<<" ntry "<<ntry<<G4endl;
if((hitPosition.x()-pointIn.x())*(hitPosition.x()-pointOut.x())>0)G4cout<<"Wrong position !!!!!!!!!!!!!!!!!!!"<<G4endl;
if((hitPosition.y()-pointIn.y())*(hitPosition.y()-pointOut.y())>0)G4cout<<"Wrong position !!!!!!!!!!!!!!!!!!!"<<G4endl;
if((hitPosition.z()-pointIn.z())*(hitPosition.z()-pointOut.z())>0)G4cout<<"Wrong position !!!!!!!!!!!!!!!!!!!"<<G4endl;
*/
           //m_dedx=driftD;
//m_de=m_dedx-m_betaGamma;
//m_tupleMdc->write();


if(((hitPosition.x()-pointIn.x())*(hitPosition.x()-pointOut.x())>0)||((hitPosition.y()-pointIn.y())*(hitPosition.y()-pointOut.y())>0)||((hitPosition.z()-pointIn.z())*(hitPosition.z()-pointOut.z())>0))wrongFlag=1;


           //Calculate signal transferT on wire
   // G4double halfLayerLength=mdcGeomSvc->Layer(layerId)->Length()/2.;
/*
G4double halfWireLength=wireLine.mag()/2.;
        G4double transferZ=0;
          if(layerId%2==0){
              transferZ=halfLayerLength+hitPosition.z(); //West readout
                }else{
                    transferZ=halfLayerLength-hitPosition.z(); //East readout
                      }
                        if(layerId<8){
                            transferT=transferZ*halfWireLength/halfLayerLength/220;
                              }else{
                                  transferT=transferZ*halfWireLength/halfLayerLength/240;
                                    }
 
  */                
//driftD=tempDriftD;

  G4double posPhi, wirePhi;
  posPhi=hitPosition.phi();//from -pi to pi
  if(posPhi<0)posPhi += 2*pi;
  wirePhi=mdcGeoPointer->SignalWire(layerId,cellId).Phi(hitPosition.z());//from 0 to 2pi


  G4int posFlag;
  if(posPhi<=wirePhi){
    posFlag    = 0;
  }else{
    posFlag    = 1;
  }
  // if x axis is between pos and wire, phi will has a jump of one of them.
  if(posPhi < 1. && wirePhi > 5.)posFlag = 1;
  if(posPhi > 5. && wirePhi < 1.)posFlag = 0;

  G4ThreeVector hitLine=pointOut-pointIn;
  G4double enterAngle=hitLine.phi()-wirePhi;
  while(enterAngle<-pi/2.)enterAngle+=pi;
  while(enterAngle>pi/2.)enterAngle-=pi;

  if(m_G4Svc->GetMdcDedxFlag()==1){
     G4double betaGamma=aStep->GetPreStepPoint()->GetBeta() * aStep->GetPreStepPoint()->GetGamma();
     if(betaGamma<0.01)return false;//too low momentum
     //if (betaGamma < 10.0) betaGamma = 10.0;

     G4double eCount=dedxSample(betaGamma, charge, theta);
     edep=eCount;
  }

  G4ThreeVector outP = postPoint->GetMomentum();

  BesMdcHit* newHit = new BesMdcHit();
  newHit->SetTrackID(truthID);
  //newHit->SetTrkID(trackID); 
  newHit->SetLayerNo(layerId);
  newHit->SetCellNo(cellId);
  newHit->SetEdep(outP.z()*1000);//yzhang
  newHit->SetPos(hitPosition);
  newHit->SetDriftD(driftD);
  newHit->SetTheta(theta);
  newHit->SetPosFlag(posFlag);
  newHit->SetEnterAngle(enterAngle);

  //Transfer hit pointer to BesMdcCalTransfer
  mdcCalPointer->SetHitPointer(newHit);

  driftT=mdcCalPointer->D2T(driftD);
  globalT+=transferT;
  driftT+=globalT;
  
  newHit->SetDriftT (driftT);
  newHit->SetGlobalT(globalT);

  std::cout<<"testdd ("<<layerId<<","<<cellId<<") dd "<<driftD<<" dt "<<driftT<<" globalT "<<globalT<<std::endl;
  if (hitPointer[layerId][cellId] == -1) {
      hitsCollection->insert(newHit);
      G4int NbHits = hitsCollection->entries();
      hitPointer[layerId][cellId]=NbHits-1;
  } 
  else if(SDlastLayer==layerId&&cellId==SDlastCell)
  {
      G4int pointer=hitPointer[layerId][cellId]; 
      if (g4TrackID == trackID) {
          G4double preDriftT=(*hitsCollection)[pointer]->GetDriftT();
      }
      
      G4double preDriftT = (*hitsCollection)[pointer]->GetDriftT();
      if (driftT < preDriftT) {   
          (*hitsCollection)[pointer]->SetTrackID(truthID);
          (*hitsCollection)[pointer]->SetEdep(outP.z()*1000);//yzhang
          (*hitsCollection)[pointer]->SetDriftD(driftD);
          (*hitsCollection)[pointer]->SetDriftT(driftT);
          (*hitsCollection)[pointer]->SetPos(hitPosition);
          (*hitsCollection)[pointer]->SetGlobalT(globalT);
          (*hitsCollection)[pointer]->SetTheta(theta);
          (*hitsCollection)[pointer]->SetPosFlag(posFlag);
          (*hitsCollection)[pointer]->SetEnterAngle(enterAngle);
      }    
   
      delete newHit;
  }else{

      hitsCollection->insert(newHit);
      G4int NbHits = hitsCollection->entries();
      hitPointer[layerId][cellId]=NbHits-1;
  }

  //for mc truth 
  if(truthCollection){
    if(g4TrackID==trackID){ //This track is the primary track & will appear in MC truth
      G4int pointer=truthPointer[layerId][cellId];  
      if(pointer==-1){
        BesMdcHit* truthHit = new BesMdcHit();
        truthHit->SetTrackID  (truthID);
        truthHit->SetLayerNo(layerId);
        truthHit->SetCellNo(cellId);
        truthHit->SetEdep     (outP.x());
        truthHit->SetPos      (pointOut);
        truthHit->SetDriftD (outP.y());
        truthHit->SetDriftT (driftT);
        truthHit->SetGlobalT(globalT);
        truthHit->SetTheta(theta);
        truthHit->SetPosFlag(posFlag);
        truthHit->SetEnterAngle(enterAngle);

        truthCollection->insert(truthHit);
        G4int NbHits = truthCollection->entries();
        truthPointer[layerId][cellId]=NbHits-1;
      } 
      else {
        if(truthID == (*truthCollection)[pointer]->GetTrackID()){
	  if(layerId==SDlastLayer&&cellId==SDlastCell){  
	    G4double preDriftT=(*truthCollection)[pointer]->GetDriftT();
	    if(driftT<preDriftT){
	      (*truthCollection)[pointer]->SetDriftD(outP.y());
	      (*truthCollection)[pointer]->SetDriftT(driftT);
	      (*truthCollection)[pointer]->SetPos(pointOut);
	      (*truthCollection)[pointer]->SetGlobalT(globalT);
	      (*truthCollection)[pointer]->SetTheta(theta);
	      (*truthCollection)[pointer]->SetPosFlag(posFlag);
	      (*truthCollection)[pointer]->SetEnterAngle(enterAngle);
	    }
	    edepTemp=(*truthCollection)[pointer]->GetEdep();
            (*truthCollection)[pointer]->SetEdep(outP.x());
	  }else{
	    BesMdcHit* truthHit = new BesMdcHit();
	    truthHit->SetTrackID  (truthID);
	    truthHit->SetLayerNo(layerId);
	    truthHit->SetCellNo(cellId);
	    truthHit->SetEdep(outP.x());
	    truthHit->SetPos(pointOut);
	    truthHit->SetDriftD (outP.y());
	    truthHit->SetDriftT (driftT);
	    truthHit->SetGlobalT(globalT);
	    truthHit->SetTheta(theta);
	    truthHit->SetPosFlag(posFlag);
	    truthHit->SetEnterAngle(enterAngle);

	    truthCollection->insert(truthHit);
	    G4int NbHits = truthCollection->entries();
	    truthPointer[layerId][cellId]=NbHits-1;
	  }

	} else {
                BesMdcHit* truthHit = new BesMdcHit();
                truthHit->SetTrackID  (truthID);
                truthHit->SetLayerNo(layerId);
                truthHit->SetCellNo(cellId);
                truthHit->SetEdep(outP.x());
                truthHit->SetPos(pointOut);
                truthHit->SetDriftD (outP.y());
                truthHit->SetDriftT (driftT);
                truthHit->SetGlobalT(globalT);
                truthHit->SetTheta(theta);
                truthHit->SetPosFlag(posFlag);
                truthHit->SetEnterAngle(enterAngle);

                truthCollection->insert(truthHit);
                G4int NbHits = truthCollection->entries();
		truthPointer[layerId][cellId]=NbHits-1;
	}
      }
    }
  }
  if(layerId==0&&SDlastLayer>0)SDenter=1;
  SDlastLayer=layerId;
  SDlastCell=cellId;
  //newHit->Print();
//  newHit->Draw();

  return true;
}

void BesMdcSD::EndOfEvent(G4HCofThisEvent*)
{
  if (verboseLevel>0) { 
  hitsCollection->PrintAllHits();
  /*
     G4int NbHits = hitsCollection->entries();
     G4cout << "\n-------->Hits Collection: in this event they are " << NbHits 
            << " hits in the MDC chambers: " << G4endl;
     for (G4int i=0;i<NbHits;i++) (*hitsCollection)[i]->Print();
  */
  } 
}

G4double BesMdcSD::Distance(G4int layerId, G4int cellId, G4ThreeVector pointIn, G4ThreeVector pointOut,G4ThreeVector& hitPosition,G4double& transferT)
{
  //For two lines r=r1+t1.v1 & r=r2+t2.v2 
  //the closest approach is d=|(r2-r1).(v1 x v2)|/|v1 x v2|
  //the point where closest approach are
  //t1=(v1 x v2).[(r2-r1) x v2]/[(v1 x v2).(v1 x v2)]
  //t2=(v1 x v2).[(r2-r1) x v1]/[(v1 x v2).(v1 x v2)]
  //if v1 x v2=0 means two lines are parallel
  //d=|(r2-r1) x v1|/|v1| 

  G4double t1,distance,dInOut,dHitIn,dHitOut;
  //Get wirepoint @ endplate
  G4ThreeVector east=mdcGeomSvc->Wire(layerId,cellId)->Backward();
  G4ThreeVector west=mdcGeomSvc->Wire(layerId,cellId)->Forward();
//G4cout<<"east "<<east<<" west "<<west<<G4endl;
  G4ThreeVector wireLine=east-west;
  G4ThreeVector hitLine=pointOut-pointIn;

  G4ThreeVector hitXwire=hitLine.cross(wireLine);
  G4ThreeVector wire2hit=east-pointOut;
  //Hitposition is the position on hit line where closest approach 
  //of two lines, but it may out the area from pointIn to pointOut
  if(hitXwire.mag()==0){
    distance=wireLine.cross(wire2hit).mag()/wireLine.mag();
    hitPosition=pointIn;
  }else{
    t1=hitXwire.dot(wire2hit.cross(wireLine))/hitXwire.mag2();
    hitPosition=pointOut+t1*hitLine;
    
    dInOut=(pointOut-pointIn).mag();
    dHitIn=(hitPosition-pointIn).mag();
    dHitOut=(hitPosition-pointOut).mag();
    if(dHitIn<=dInOut && dHitOut<=dInOut){ //Between point in & out
      distance=fabs(wire2hit.dot(hitXwire)/hitXwire.mag());
    }else if(dHitOut>dHitIn){ // out pointIn
      distance=wireLine.cross(pointIn-east).mag()/wireLine.mag();
      hitPosition=pointIn;
    }else{ // out pointOut
      distance=wireLine.cross(pointOut-east).mag()/wireLine.mag(); 
      hitPosition=pointOut;
    }
  }

  //Calculate signal transferT on wire
  G4double halfLayerLength=mdcGeomSvc->Layer(layerId)->Length()/2.;
  G4double halfWireLength=wireLine.mag()/2.;
  G4double transferZ=0;
  if(layerId%2==0){
    transferZ=halfLayerLength+hitPosition.z(); //West readout
  }else{
    transferZ=halfLayerLength-hitPosition.z(); //East readout
  }
  if(layerId<8){
    transferT=transferZ*halfWireLength/halfLayerLength/220;
  }else{
    transferT=transferZ*halfWireLength/halfLayerLength/240;
  }

  return distance;

}

void BesMdcSD::dedxFuncInti(void)
{
    dEdE_mylanfunc = new TF1("dEdE_mylanfunc",
                             "[3]*TMath::Exp([2]*((x[0]-[0])/[1]+TMath::Exp(-1*((x[0]-[0])/[1]))))",
                             0,
                             7500);
    //dEdE_mylanfunc->SetParameters(2009.35,559.776,-1.0932,6327.38);
    dEdE_mylanfunc->SetParNames("MPV","Sigma","constant1","constant2");
}

G4double BesMdcSD::dedxSample(G4double betagamma, G4double charge, G4double theta)
{
    G4double x = betagamma;
    G4double fitval = GetValDedxCurve(x, charge);
    if(fitval <= 0)return 0;
   
    G4double random1, random2, dedx1, dedx2, de;
    G4double standard1, standard2, beta_temp1, beta_temp2;
    G4double dedx = -1;

    G4int range_idx, bg_idx, angle_idx, charge_idx, hist_idx;
    range_idx = GetBetagammaIndex(betagamma);
    angle_idx = GetAngleIndex(theta);
    charge_idx = GetChargeIndex(charge);
    
    if (range_idx == -1)
    {
        while (dedx <= 0)
        {
            bg_idx = 0;
            hist_idx = bg_idx * 2 * 10 + angle_idx * 2 + charge_idx;
            random1 = m_dedx_hists[hist_idx].GetRandom();
            beta_temp1 = (m_bgRange[0] + m_bgRange[1]) / 2;
            standard1 = GetValDedxCurve(beta_temp1, charge); 
            dedx = random1 + fitval - standard1;
        }
    }
    else if (range_idx == m_numBg - 1)
    {
        while (dedx <= 0)
        {
            bg_idx = (G4int)(range_idx / 2);
            hist_idx = bg_idx * 2 * 10 + angle_idx * 2 + charge_idx;
            random1 = m_dedx_hists[hist_idx].GetRandom();
            beta_temp1 = (m_bgRange[m_numBg - 2] +
                          m_bgRange[m_numBg - 1]) / 2;
            standard1 = GetValDedxCurve(beta_temp1, charge);
            dedx = random1 + fitval - standard1;
        }     
    }
    else
    {
        //case 1: Given betagamma fall in one histograph range
        if (range_idx % 2 == 0)
        {
            while (dedx <= 0)
            {
                bg_idx = (G4int)(range_idx / 2);
                hist_idx = bg_idx * 2 * 10 + angle_idx * 2 + charge_idx;
                random1 = m_dedx_hists[hist_idx].GetRandom();
                beta_temp1 = (m_bgRange[range_idx] + 
                              m_bgRange[range_idx + 1]) / 2;
                standard1 = GetValDedxCurve(beta_temp1, charge); 
                dedx1 = random1 + fitval - standard1;
                dedx = dedx1;
            }
        }
        //case 2: Given betagamma fall in interval between
        //        two histographs.
        else
        {
            while (dedx <= 0)
            {
                //standard1
                beta_temp1 = (m_bgRange[range_idx - 1] + 
                              m_bgRange[range_idx]) / 2;
                standard1 = GetValDedxCurve(beta_temp1, charge);

                //stardard2
                beta_temp2 = (m_bgRange[range_idx + 1] + 
                              m_bgRange[range_idx + 2]) / 2;
                standard2 = GetValDedxCurve(beta_temp2, charge);
               
                //random1 
                bg_idx = (G4int)(range_idx / 2);
                hist_idx = bg_idx * 2 * 10 + angle_idx * 2 + charge_idx;
                random1 = m_dedx_hists[hist_idx].GetRandom();

                //random2
                bg_idx++;
                hist_idx = bg_idx * 2 * 10 + angle_idx * 2 + charge_idx;
                random2 = m_dedx_hists[hist_idx].GetRandom();

                //combine dedx1 and dedx2
                dedx1 = random1 + fitval - standard1;
                dedx2 = random2 + fitval - standard2;
                dedx = (dedx2 * (x - m_bgRange[range_idx]) + 
                        dedx1 * (m_bgRange[range_idx + 1] - x)) / 
                       (m_bgRange[range_idx + 1] - m_bgRange[range_idx]);
            }
        }
    }
   
   
    de= dedx;// * y/10./1.5;// stepLength unit is mm in Geant4, cm in Rec.& Cal. software 
                         // dedx counts *1.5 in dedx Cal.
   
    if(m_G4Svc->MdcRootFlag())
    {
       m_betaGamma= x;
       m_fitval= fitval;
       //m_trackId = trackId; 
       //m_layer = layerId; 
       //m_wire  = cellId; 
       //m_random= random;
       m_dedx= dedx;
       m_de= de;
       //m_length=y;
       m_charge = charge;
       m_costheta = cos(theta);
       m_tupleMdc->write(); 
    }
    return de;
}

/*-----------------------------------------------------
Func: GetValDedxCurve
Pre: A betagamma is given.
Post: Return dE/dx value from betagamma~dE/dx curve.
-----------------------------------------------------*/
G4double BesMdcSD::GetValDedxCurve(G4double x, G4double charge)
{
    G4int dedxflag = -1;
    G4int size = -1;
    G4double A = 0.;
    G4double B = 0.;
    G4double C = 0.;
    std::vector<G4double> par;
    G4double val;
    G4int index = -1;

    par.clear();
    dedxflag = m_pDedxCurSvc->getCurve(0);
    size = m_pDedxCurSvc->getCurveSize();
    for (G4int i = 1; i < size; i++) {
        par.push_back(m_pDedxCurSvc->getCurve(i));
    }

    if (x < 4.5)
        A = 1;
    else if(x < 10)
        B = 1;
    else
        C = 1;
    
    G4double partA = par[0] * pow(sqrt(x * x + 1), par[2]) / pow(x, par[2]) *
                  (par[1] - par[5] * log(pow(1 / x, par[3]))) -
                   par[4] + exp(par[6] + par[7] * x);
    G4double partB = par[8] * pow(x, 3) + par[9] * pow(x, 2) + par[10] * x + par[11];
    G4double partC = - par[12] * log(par[15] + pow(1 / x, par[13])) + par[14];
    
    val = 550 * (A * partA + B * partB + C * partC);
    return val;
    
}

/*-----------------------------------------------------
Func: GetBetagammaIndex
Pre : A betagamma of a track is given. 
Post: Return index of the betagamma range.
-----------------------------------------------------*/
G4int BesMdcSD::GetBetagammaIndex(G4double bg)
{
    if (bg < m_bgRange[0]) return -1;
    for (G4int i = 0; i < m_numBg - 1; i++)
    {
        if (bg > m_bgRange[i] && bg < m_bgRange[i + 1])
        {
            return i;
        }
    }
    if (bg > m_bgRange[m_numBg - 1])
        return (m_numBg - 1);
}

/*-----------------------------------------------------
Func: GetAngleIndex
Pre : A theta of a track is given.
Post: Return index of the angle (floor(|cos(theta)| * 10)).
-----------------------------------------------------*/
G4int BesMdcSD::GetAngleIndex(G4double theta)
{
    if (fabs(cos(theta)) >= 0.93) return 9;
    return (G4int)(fabs(cos(theta)) * 10 / 0.93);
}

/*-----------------------------------------------------
Func: GetChargeIndex
Pre : A charge of a track is given.
Post: Return index of charge (pos->0 ~ neg->1).
-----------------------------------------------------*/
G4int BesMdcSD::GetChargeIndex(G4int charge)
{
    if (charge > 0)  return 0;
    if (charge == 0) return -1;  // warning: -1 is illegal, for charged tracks are expected.
    if (charge < 0)  return 1;
}

void BesMdcSD::for_Rotat(const G4double bfld[3])

  {

    //Calculates a rotation matrix in advance at a local position in lab.

    //The rotation is done about the coord. origin; lab.-frame to B-field

    //frame in which only Bz-comp. is non-zero.

    //~dead copy of gsim_cdc_for_rotat.F in gsim-cdc for Belle (for tentaive use)


    if (m_nonUniformField == 0) return;


    G4double bx, by, bz;

    bx = bfld[0];

    by = bfld[1];

    bz = bfld[2];


    //cal. rotation matrix

    G4double bxz, bfield;

    bxz    = bx * bx + bz * bz;

    bfield = bxz   + by * by;

    bxz    = sqrt(bxz);

    bfield = sqrt(bfield);


    brot[0][0] = bz / bxz;

    brot[1][0] = 0.;

    brot[2][0] = -bx / bxz;

    brot[0][1] = -by * bx / bxz / bfield;

    brot[1][1] = bxz     / bfield;

    brot[2][1] = -by * bz / bxz / bfield;

    brot[0][2] = bx / bfield;

    brot[1][2] = by / bfield;

    brot[2][2] = bz / bfield;


    return;


  }


  void BesMdcSD::Rotat(G4double& x, G4double& y, G4double& z,

                              const int mode)

  {

    //Translates (x,y,z) in lab. to (x,y,z) in B-field frame (mode=1), or reverse

    // translation (mode=-1).

    //~dead copy (for tentaive use) of gsim_cdc_rotat/irotat.F in gsim-cdc

    //for Belle


    if (m_nonUniformField == 0) return;



    G4double x0(x), y0(y), z0(z);


    if (mode  == 1) { 

      x = brot[0][0] * x0 + brot[1][0] * y0 + brot[2][0] * z0;

      y = brot[0][1] * x0 + brot[1][1] * y0 + brot[2][1] * z0;

      z = brot[0][2] * x0 + brot[1][2] * y0 + brot[2][2] * z0;

    } else if (mode == -1) {

      x = brot[0][0] * x0 + brot[0][1] * y0 + brot[0][2] * z0;

      y = brot[1][0] * x0 + brot[1][1] * y0 + brot[1][2] * z0;

      z = brot[2][0] * x0 + brot[2][1] * y0 + brot[2][2] * z0;

    } else {

      //B2ERROR("SensitiveDetector " <<"invalid mode " << mode << "specifed");

    }

    return;


  }


  void
  
  BesMdcSD::Rotat(G4double x[3], const int mode)

  {

    //Translates (x,y,z) in lab. to (x,y,z) in B-field frame (mode=1), or reverse

    // translation (mode=-1).

    //~dead copy (for tentaive use) of gsim_cdc_rotat/irotat.F in gsim-cdc

    //for Belle



    if (m_nonUniformField == 0) return;


    G4double x0(x[0]), y0(x[1]), z0(x[2]);


    if (mode  == 1) {

      x[0] = brot[0][0] * x0 + brot[1][0] * y0 + brot[2][0] * z0;

      x[1] = brot[0][1] * x0 + brot[1][1] * y0 + brot[2][1] * z0;

      x[2] = brot[0][2] * x0 + brot[1][2] * y0 + brot[2][2] * z0;

    } else if (mode == -1) {

      x[0] = brot[0][0] * x0 + brot[0][1] * y0 + brot[0][2] * z0;

      x[1] = brot[1][0] * x0 + brot[1][1] * y0 + brot[1][2] * z0;

      x[2] = brot[2][0] * x0 + brot[2][1] * y0 + brot[2][2] * z0;

    } else {

      //B2ERROR("SensitiveDetector " <<"invalid mode " << mode << "specifed");

    }

    return;


  }


  void

  BesMdcSD::HELWIR(const G4double xwb4, const G4double ywb4,

                               const G4double zwb4,

                               const G4double xwf4, const G4double ywf4,

                               const G4double zwf4,

                               const G4double xp, const G4double yp,

                               const G4double zp,

                               const G4double px, const G4double py,

                               const G4double pz,

                               const G4double B_kG[3],

                               const G4double charge, const G4int ntryMax,

                               G4double& distance,

                               G4double q2[3], G4double q1[3],

                               G4int& ntry)

  {

    //~dead copy of gsim_cdc_hit.F in gsim-cdc for Belle (for tentaive use)

    // ---------------------------------------------------------------------

    //     Purpose : Calculate closest points between helix and wire.

    //

    //     Input

    //         xwb4 : x of wire at backward endplate in lab.

    //         ywb4 : y of wire at backward endplate   "

    //         zwb4 : z of wire at backward endplate   "

    //         xwf4 : x of wire at forward  endplate   "

     //         ywf4 : y of wire at forward  endplate   "
  
     //         zwf4 : z of wire at forward  endplate   "

     //

     //     Output

     //         q2(1) : x of wire  at closest point in lab.

     //         q2(2) : y of wire  at closest point   "

     //         q2(3) : z of wire  at closest point   "

     //         q1(1) : x of helix at closest point   "

     //         q1(2) : y of helix at closest point   "

     //         q1(3) : z of helix at closest point   "

     //         ntry  :

     // ---------------------------------------------------------------------


     const G4int ndim = 3;

     const G4double delta = 1.e-5;


     G4double fi4;

     G4double xwb, ywb, zwb, xwf, ywf, zwf;

     G4double xw, yw, zw, xh, yh, zh;

     G4double fi, fi_corr;


     G4double dr, fi0, cpa, dz, tanl;

     G4double x0, y0, z0;

     G4double xc, yc, r, chrg;

     G4double xwm, ywm;

     G4double sinfi0, cosfi0, sinfi0fi, cosfi0fi;


     G4double vx, vy, vz, vv, cx, cy, cz, tt[3][3];

     G4double tmp[3];


     G4double xx[3], dxx[3], ddxx[3];

     G4double xxtdxx, dxxtdxx, xxtddxx;


     G4double fst, f, fderiv, deltafi, fact, eval;

     G4double fist;


     G4double dx1, dy1, dx2, dy2, crs, dot;


     G4int iflg;



     //set parameters

     xwb = xwb4;  ywb = ywb4;  zwb = zwb4;

     xwf = xwf4;  ywf = ywf4;  zwf = zwf4;


     G4double xxx(xp), yyy(yp), zzz(zp);

     G4double pxx(px), pyy(py), pzz(pz);


     //rotate z-axis to be parallel to B-field in case of non-uniform B

     Rotat(xwb, ywb, zwb, 1);

     Rotat(xwf, ywf, zwf, 1);

     Rotat(xxx, yyy, zzz, 1);

     Rotat(pxx, pyy, pzz, 1);


     G4double a[8] = {0.};

     G4double pt = sqrt(pxx * pxx + pyy * pyy);

     a[1] = atan2(-pxx, pyy);

     a[2] = charge / pt;

     a[4] = pzz   / pt;

     a[5] = xxx;  a[6] = yyy;  a[7] = zzz;


     //calculate unit direction vector of the sense wire

     vx = xwf - xwb;  vy = ywf - ywb;  vz = zwf - zwb;

     vv = sqrt(vx * vx + vy * vy + vz * vz);

     vx /= vv;  vy /= vv;  vz /= vv;


     //flag for distingushing between stereo and axial wire

     iflg = 0;

     if (vx == 0. &&  vy == 0.) iflg = 1;

     //  std::cout << "iflg= " << iflg << std::endl;

     //write(6,*) ' hlx2wir ', xwb, ywb, zwb, vx, vy, vz


     //calculate coefficients of f

     cx = xwb - vx * (vx * xwb + vy * ywb + vz * zwb);

     cy = ywb - vy * (vx * xwb + vy * ywb + vz * zwb);

     cz = zwb - vz * (vx * xwb + vy * ywb + vz * zwb);


     //calculate tensor for f

     tt[0][0] = vx * vx - 1.;  tt[1][0] = vx * vy;       tt[2][0] = vx * vz;

     tt[0][1] = vy * vx;       tt[1][1] = vy * vy - 1.;  tt[2][1] = vy * vz;

     tt[0][2] = vz * vx;       tt[1][2] = vz * vy;       tt[2][2] = vz * vz - 1.;


     //set helix parameters

     dr   = a[0];   fi0  = a[1];  cpa  = a[2];

     dz   = a[3];   tanl = a[4];

     x0   = a[5];   y0   = a[6];  z0   = a[7];

     fi4  = 0.;


     //set initial value for fi

     if (fi4 == 0. || iflg == 1) {

       xwm    = 0.5 * (xwb + xwf);

       ywm    = 0.5 * (ywb + ywf);

       //r(cm) = alpha/cpa = alpha * pt(GeV); bfield(kG)

       G4double bfield = sqrt(B_kG[0] * B_kG[0] +

                              B_kG[1] * B_kG[1] +

                              B_kG[2] * B_kG[2]);

       alpha  = 1.e4 / 2.99792458 / bfield;

       r      = alpha / cpa;

       cosfi0 = cos(fi0);

       sinfi0 = sin(fi0);

       chrg   = 1.; if (r < 0.) chrg = -1.;

       xc  = x0 + (dr + r) * cosfi0;

       yc  = y0 + (dr + r) * sinfi0;

       dx1 = x0 - xc;

       dy1 = y0 - yc;

       dx2 = xwm - xc;

       dy2 = ywm - yc;

       crs = dx1 * dy2 - dy1 * dx2;

       dot = dx1 * dx2 + dy1 * dy2;

       fi = atan2(crs, dot);

     } else {

       fi = fi4;

     }

     //write(6,*) ' fi st ', fi, ' fi0 ', fi0, ' fi0fi ', fi0fi,

     //.    ' chrg ', chrg


     //begin iterative procedure for newton 's method   '

     fact = 1.;

     ntry = 0;

 line1:

     ntry += 1;

     cosfi0fi = cos(fi0 + fi);

     sinfi0fi = sin(fi0 + fi);


     //calculate spatial point Q(x,y,z) along the helix

     xx[0] = x0 + dr * cosfi0 + r * (cosfi0 - cosfi0fi);

     xx[1] = y0 + dr * sinfi0 + r * (sinfi0 - sinfi0fi);

     xx[2] = z0 + dz        - r * tanl * fi;


     if (iflg  == 1) {

       q2[0] = xwb;    q2[1] = ywb;    q2[2] = xx[2];

       q1[0] = xx[0];  q1[1] = xx[1];  q1[2] = xx[2];

       //inverse rotation to lab. frame in case of non-uniform B

       Rotat(q1, -1);

       Rotat(q2, -1);

       distance = sqrt((q2[0] - q1[0]) * (q2[0] - q1[0]) +

                       (q2[1] - q1[1]) * (q2[1] - q1[1]) +

                       (q2[2] - q1[2]) * (q2[2] - q1[2]));

       return;

     }


     //calculate direction vector (dx/dphi,dy/dphi,dz/dphi)

     //on a point along the helix.

     dxx[0] =   r * sinfi0fi;  dxx[1] = - r * cosfi0fi;  dxx[2] = - r * tanl;

  
     //   In order to derive the closest pont between straight line and helix,

     //   we can put following two conditions:

     //     (i)  A point H(xh,yh,zh) on the helix given should be on

     //          the plane which is perpendicular to the straight line.

     //     (ii) A line HW from W(xw,yw,zw) which is a point on the straight

     //          line to H(xh,yh,zh) should normal to the direction vector

     //          on the point H.

     //

     //   Thus, we can make a equation from above conditions.

     //     f(phi) = cx*(dx/dphi) + cy*(dy/dphi) + cz*(dz/dphi)

     //              + (x,y,z)*tt(i,j)*(dx/dphi,dy/dphi,dz/dphi)


     //            = 0,

     //     where

     //      cx      = xwb - vx*( vx*xwb + vy*ywb + vz*zwb )

     //      cy      = ywb - vy*( vx*xwb + vy*ywb + vz*zwb )

     //      cz      = zwb - vz*( vx*xwb + vy*ywb + vz*zwb )

     //

     //      tt(1,1) = vx*vx - 1  tt(1,2) = vx*vy      tt(1,3) = vx*vz

     //      tt(2,1) = vy*vx      tt(2,2) = vy*vy - 1  tt(2,3) = vy*vz

     //      tt(3,1) = vz*vx      tt(3,2) = vz*vy      tt(3,3) = vz*vz - 1

     //

     //     and the equation of straight line(stereo wire) is written by

     //     (x,y,z) = (xwb,ywb,zwb) + beta*(vx,vy,vz), beta is free parameter.


     //Now calculate f

     Mvopr(ndim, xx, tt, dxx, tmp, 1);

     xxtdxx = tmp[0];

     f = cx * dxx[0] + cy * dxx[1] + cz * dxx[2] + xxtdxx;

     if (std::abs(f) < delta) goto line100;


     //evaluate fitting result and prepare some factor to multiply to 1/derivative

     if (ntry > 1) {

       eval = (1.0 - 0.25 * fact) * std::abs(fst) - std::abs(f);

       if (eval <= 0.) fact *= 0.5;

     }


     //calculate derivative of f

     ddxx[0] = r * cosfi0fi;  ddxx[1] = r * sinfi0fi;  ddxx[2] = 0.;


     //Now we have derivative of f

     Mvopr(ndim, dxx, tt,  dxx, tmp, 1);

     dxxtdxx = tmp[0];

     Mvopr(ndim,  xx, tt, ddxx, tmp, 1);

     xxtddxx = tmp[0];

     fderiv = cx * ddxx[0] + cy * ddxx[1] + cz * ddxx[2] + dxxtdxx + xxtddxx;


     fist    = fi;

     deltafi = f / fderiv;

     fi     -= fact * deltafi;

     fst     = f;


     if (ntry > ntryMax) {

       //B2DEBUG(" Exceed max. trials HelWir ");

       goto line100;

     }

     //write(6,*) ntry, fist, deltafi

     goto line1;


     //check if zh is btw zwb and zwf; if not, set zh=zwb or zh=zwf.

 line100: 

     zh  = z0 + dz - r * tanl * fi;

     fi_corr = 0.;

     if (zh  < zwb) fi_corr = (zwb - zh) / (-r * tanl);

     if (zh  > zwf) fi_corr = (zwf - zh) / (-r * tanl);

     fi += fi_corr;


     cosfi0fi = cos(fi0 + fi);

     sinfi0fi = sin(fi0 + fi);


     xh  = x0 + dr * cosfi0 + r * (cosfi0 - cosfi0fi);

     yh  = y0 + dr * sinfi0 + r * (sinfi0 - sinfi0fi);

     zh  = z0 + dz        - r * tanl * fi;


     //write(6,*) 'fi_corr, zh, zwb, zwf=', fi_corr, zh, zwb, zwf

     //write(6,*) 'zh = ', z0, dz, r, tanl, fi


     zw = vx * vz * xh + vy * vz * yh + vz * vz * zh + zwb - vz * (vx * xwb + vy * ywb + vz * zwb);

     xw = xwb + vx * (zw - zwb) / vz;

     yw = ywb + vy * (zw - zwb) / vz;


     q2[0] = xw;  q2[1] = yw;  q2[2] = zw;

     q1[0] = xh;  q1[1] = yh;  q1[2] = zh;


     //inverse rotation to lab. frame in case of non-uniform B

     Rotat(q1, -1);

     Rotat(q2, -1);
     distance = sqrt((q2[0] - q1[0]) * (q2[0] - q1[0]) +

                     (q2[1] - q1[1]) * (q2[1] - q1[1]) +

                     (q2[2] - q1[2]) * (q2[2] - q1[2]));

     return; 


   }

void BesMdcSD::Mvopr(const G4int ndim, const G4double b[3], const G4double m[3][3],

                               const G4double a[3], G4double c[3], const G4int mode)

   {

     //~dead copy of UtilCDC_mvopr in com-cdc for Belle (for tentative use)

     //-----------------------------------------------------------------------

     //     Input

     //         ndim             : dimension

     //         b(1-ndim)        : vector

     //         m(1-ndim,1-ndim) : matrix

     //         a(1-ndim)        : vector

     //         c(1-ndim)        : vector

     //         mode             : c = m * a     for mode=0

     //                            c = b * m * a for mode=1

     //     Output

     //         c(1-ndim)        : for mode 1, solution is put on c[0]

     //-----------------------------------------------------------------------


     if (ndim != 3) {

       //B2ERROR("invalid ndim " << ndim << " specified");

       return;

     }


     for (int i = 0; i < ndim; i++)   c[i] = 0.;

     G4double tmp[3];

     for (int i = 0; i < ndim; i++) tmp[i] = 0.;


     if (mode == 0) {

       for (int i = 0; i < ndim; i++) {

         for (int j = 0; j < ndim; j++) {

           c[i] += m[j][i] * a[j];

         }

       }

       return;

     } else if (mode == 1) {

       for (int i = 0; i < ndim; i++) {

         for (int j = 0; j < ndim; j++) {

           tmp[i] += m[j][i] * a[j];

         }

         c[0] += b[i] * tmp[i];

       }

     } else {

       //B2ERROR("Error, you specified invalid mode= " << mode);

     }


     return;


   }


